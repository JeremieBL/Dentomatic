#version 330 core
out vec4 fragColor;

in vec3 fragNormal;
in vec3 fragPosition;

uniform vec3 viewPos;      // Camera position
uniform vec3 toothColor;   // Base tooth colour

// ------------------------------------------------------------------
// Light description
// ------------------------------------------------------------------
struct Light {
    int   type;      // 0 = directional, 1 = point
    vec3  position;  // world position (point lights only)
    vec3  direction; // normalized direction (directional lights only)
    vec3  color;     // light colour / intensity
};

#define MAX_LIGHTS 64
uniform Light lights[MAX_LIGHTS];
uniform int   numLights;   // <= MAX_LIGHTS

// ------------------------------------------------------------------
// Helper: simple quadratic attenuation for point lights
// ------------------------------------------------------------------
float attenuate(vec3 lightPos)
{
    const float constant  = 1.0;
    const float linear    = 0.09;
    const float quadratic = 0.032;

    float d = length(lightPos - fragPosition);
    return 1.0 / (constant + linear * d + quadratic * (d * d));
}

// ------------------------------------------------------------------
// Compute contribution of ONE light (directional or point)
// ------------------------------------------------------------------
vec3 CalcLight(Light light, vec3 N, vec3 V)
{
    vec3 L;               // light direction (towards the fragment)
    float att = 1.0;      // attenuation (1 for directional)

    if (light.type == 0) {                     // directional
        L = normalize(-light.direction);
    } else {                                   // point
        L   = normalize(light.position - fragPosition);
        att = attenuate(light.position);
    }

    // ---- Ambient (per-light, tiny) ----
    const float ambientStrength = 0.2;
    vec3 ambient = ambientStrength * light.color * att;

    // ---- Diffuse ----
    float diff = max(dot(N, L), 0.0);
    vec3 diffuse = diff * light.color * att;

    // ---- Specular (Blinn-Phong) ----
    const float specularStrength = 0.8;
    vec3  R = reflect(-L, N);
    float spec = pow(max(dot(V, R), 0.0), 32.0);
    vec3 specular = specularStrength * spec * light.color * att;

    // ---- Translucency (your original soft back-light) ----
    const float translucency = 0.1;
    vec3 translucent = translucency * light.color * (1.0 - diff) * att;

    return (ambient + diffuse + specular) * toothColor + translucent;
}

// ------------------------------------------------------------------
void main()
{
    vec3 N = normalize(fragNormal);
    vec3 V = normalize(viewPos - fragPosition);

    vec3 result = vec3(0.0);

    // Sum contributions of all active lights
    for (int i = 0; i < numLights; ++i)
        result += CalcLight(lights[i], N, V);

    fragColor = vec4(result, 1.0);
}
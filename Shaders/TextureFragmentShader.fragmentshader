#version 330 core

in vec3 Position_worldspace;

// Ouput data
out vec3 color;

// Values that stay constant for the whole mesh.
uniform sampler2D myTextureSampler;



uniform int colomapmod;

uniform float minToClamp;
uniform float maxToClamp;




vec3 Rainbow(float f)
{
	const float dx = 0.8;

	float g = (6-2*dx)*f + dx;

	float R = max(0,(3-abs(g-4)-abs(g-5))/2);
	float G = max(0,(4-abs(g-2)-abs(g-4))/2);
	float B = max(0,(3-abs(g-1)-abs(g-2))/2);

	return vec3(R, G, B);
}

vec3 Grayscale(float f)
{
	return vec3(f, f, f);
}

vec3 Two_Hue(float f)
{
	vec3 col1 = vec3(0.15, 0.78, 0.45);
	vec3 col2 = vec3(0.65, 0.32, 0.86);

	return (1.0f-f)*col1 + f*col2;
}

vec3 HeatMap(float f)
{
	const float dx = 0.8;

	float g = (6-2*dx)*f + dx;

	float R = max(0,(6-abs(g-3)-abs(g-6))/2);
	float G = max(0,(3-abs(g-6))/2);

	return vec3(R, G, 0);
}

vec3 Diverging(float f)
{
	vec3 col1 = vec3(0.15, 0.78, 0.45);
	vec3 col2 = vec3(0.65, 0.32, 0.86);
	vec3 mid = (col1 + col2)/1.25;


	return (f<0.5)? ((1.0f-f*2)*col1 + f*2*mid):((1.0f-(f-0.5)*2)*mid + (f-0.5)*2*col2);
}



void main(){

	float f = Position_worldspace.z;

	f = (f-minToClamp)/(maxToClamp-minToClamp);

//	f = (f<0)?0 : (f>1)? 1:f;

	switch(colomapmod)
	{
	case 0:
		color = Rainbow(f);
		break;
	case 1:
		color = Grayscale(f);
		break;
	case 2:
		color = Two_Hue(f);
		break;
	case 3:
		color = HeatMap(f);
		break;
	case 4:
		color = Diverging(f);
		break;
	default:
		color = Rainbow(f);
	break;
	}	
}